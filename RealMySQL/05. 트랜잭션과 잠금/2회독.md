# 트랜잭션

데이터베이스에서 수행하는 최소한의 논리적(원자적) 단위로, 하나 이상의 데이터베이스 연산의 모임이다. 데이터베이스는 ACID 특성을 보장해야하고, 해당 특성은 트랜잭션에서부터 보장된다.

데이터베이스에서 트랜잭션을 수행하는 모듈을 '트랜잭션 관리기 (transaction manager)' 모듈이라고 한다. 해당 모듈은 회복 (recovery) 모듈과 동시성 관리 (concurrency control) 모듈로 이루어져있다.


## ACID
### Atomicity 원자성

all or nothing을 의미한다.
앞서서 트랜잭션을 하나의 ‘원자적’ 단위라고 했다.
Atomic하다는 표현은 대게 ‘더 이상 쪼개어지지 않음’을 뜻한다.
그렇기 때문에 전부 수행되거나 (commit), 전부 수행되지 않는다 (abort → rollback).

번외. rollback이 수행되는 경우
- 시스템 고장
- 트랜잭션 고장: 사용자가 취소, 데드락에 의해 희생, 예외처리 발생 
- 매체 고장: 디스크 장치 고장 → 회복 모듈로 해결 불가

### Consistency 일관성

데이터 일관성과 데이터 무결성 (integrity)은 함께 쓰이는 경우가 많은데 정확히 무엇이 다를까?
무결성 제약조건은 데이터가 정확하고 일관되게 유지되는 것을 보장한다.
그리고 데이터베이스가 모든 무결성 제약 조건을 만족하는 것을 '일관적 상태'를 가진다고 한다.

일관적 상태를 가진 데이터베이스는, 트랜잭션 후 새로운 일관적 상태를 가진다.
일관성은, 테이블에 명시된 무결성 제약조건과 관계 DBMS의 동시성 제어 모듈에 의해 유지된다.

### Isolation 고립성 (독립성)

각 트랜잭션은 고립되어 (하나씩 차례대로) 수행한 것과 결과가 같아야 한다.
단, 순차적 수행은 성능이 떨어지기때문에 동시에 여러 트랜잭션이 수행되는데, 이 경우에도 서로 영향을 끼치지 않으며 결과는 고립되게 보장되어야한다.
동시성 제어 모듈이 이를 보장한다.
다만 순차적 수행과 완전히 동일한 결과를 보장하게 되는 경우 성능이 떨어지기 때문에 요구 사항에 따라 해당 고립성의 수준 (Isolation level)을 조절할 수 있다.

### Durability 지속성


## 동시성

트랜잭션은 동시성을 지원한다. 당연하지만 성능을 위해서이다.
DBMS에서 가장 시간이 많이 소요되는 것은 디스크에 직접 I/O할 때이다.
트랜잭션을 순차적으로 실행하는 경우 I/O하는 시간동안 CPU는 놀고 있게 된다.
그렇기 때문에 트랜잭션은 여러 개가 동시에 수행되며, 이를 동시성이라고 한다.

동시성 제어 모듈은 동시성을 제공하며 ACID 특성을 보장하기 위해 로킹을 사용한 스케쥴링을 지원한다.

### 스케쥴링과 로킹



### 팬텀 문제

2단계 로킹 프로토콜을 지키는 경우, 스케쥴의 직렬가능성이 보장된다. 직렬가능성이란, 트랜잭션을 직렬로 수행했을 때와 동일한 결과를 보인다는 뜻이다. 하지만 이 전제는 테이블이 '정적'일 때에만 성립한다. 여러 트랜잭션이 수행됨에 따라 테이블은 '동적'으로 상태가 변하고, 이에 따라 수행되는 일부 기간에는 보이지 않다 어느 수행기간에 보이게 되는 레코드가 발생하게 된다. 해당 레코드를 '팬텀'이라고 부르며, 팬텀문제가 발생한다고 한다.

## 회복

트랜잭션을 rollback할 때, 그리고 어떠한 문제로 인해 데이터를 원상복구해야할 때 회복 모듈이 사용된다.
회복 모듈은 로그를 사용하여 회복을 수행한다.


# MySQL에서의 트랜잭션

MySQL의 스토리지 엔진 중 트랜잭션을 제공하는 것은 InnoDB 뿐이다.

MyISAM 엔진의 경우 트랜잭션을 지원하지 않고, DML 실행 시에는 테이블 락을 사용한다. 따라서 읽기 전용에서 성능 최적화를 위해 주로 사용한다.

트랜잭션을 제공하지 않는 경우에는 오류 발생 시의 헨들링을 직접 구현해야하며, 구현하지 않는 경우 데이터의 정합성을 맞추기 매우 어렵게 한다.

단, 트랜잭션을 사용할 때는 범위를 최소화해야한다. 트랜잭션 당 커넥션을 생성하게 되는데, 트랜잭션이 길어질수록 여유 커넥션의 개수도 줄어들고, 데이터베이스에서도 락을 유지하는 시간이 길어지게 된다.

번외. Spring에서는 언제 트랜잭션을 시작하는가?
트랜잭션이 필요한 경우 커넥션을 생성하는데, 자주 사용하는 @Transactional은 해당 메서드 호출 시 트랜잭션을 시작, 완료 후 commit 또는 rollback을 수행한다. 따라서 @Transactional을 사용할 때 조심해야한다.


# MySQL 엔진 잠금

MySQL 엔진 레벨의 잠금은 테이블이나 데이터베이스 자체를 다루는 데 사용되며, 스토리지 엔진은 테이블의 데이터에 대한 잠금을 처리한다.

그러면 MySQL 엔진 레벨의 잠금에는 무엇이 있을까?
데이터베이스 전체를 잠그는 것이 존재할 것이다.
- 말 그대로 모든 데이터베이스의 테이블을 잠글 수도 있고 (Global Lock)
- 어떠한 조건을 가지고 데이터베이스 전체에 적용할 수도 있을 것이다 (Named Lock)

또한 테이블을 잠그는 것이 존재할 것이다.
- 말 그대로 테이블 전체의 데이터를 잠글 수도 있고 (Table Lock)
- 테이블의 정보를 잠글 수도 있을 것이다 (Meta Data Lock)


# 스토리지 엔진 잠금

InnoDB의 경우 레코드 기반의 잠금을 지원한다. 여기서 중요한 것은, 이것이 인덱스 테이블에 저장된 인덱스 레코드를 잠금한다는 것이다.

## 인덱스와 잠금

InnoDB는 락을 걸 때, 해당되는 인덱스에 락을 건다. 변경해야할 레코드를 찾는다면, 해당 인덱스의 모든 레코드에 락을 건다는 뜻이다. 만약 인덱스가 없다면 모든 레코드에 락을 걸게 된다.

그리고 이 때문에 레코드 락과 넥스트 키 락이 나뉘게 된다.

### 레코드 락

레코드 자체 (해당 인덱스 레코드)만 잠그는 것을 레코드 락이라고 한다. 클러스터 인덱스 (PK)나 유니크 인덱스를 사용하는 경우 레코드 락을 사용한다.

### 넥스트 키 락

클러스터 인덱스와 유니크 인덱스가 아닌 인덱스를 보조 인덱스라 한다. 보조 인덱스의 경우 해당 인덱스를 가진 새로운 값이 존재할 수 있다. 그렇기 때문에 갭 락을 사용하여 다음 인덱스 (키)까지의 범위에 모두 락을 거는 것이다.
- 갭 락: 레코드 자체가 아닌 레코드와 레코드 사이의 간격에 락을 거는 것이다.

다시 잠깐 레코드 락으로 돌아가자면, 클러스터 인덱스나 유니크 인덱스의 경우 다음 인덱스까지 락을 걸지 않아도 단 1개만 주어지기 때문에 다음 키 까지의 락이 필요없다고 볼 수 있다.

책에는 STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEAYABLE READ 격리수준을 사용하고, 해당 상황에서 레플리카 서버를 소스 서버의 결과와 동일하게 만들어내도록 보장하기 위해 넥스트 키 락을 사용한다고 한다.

이것이 무슨 말인지 하나하나 뜯으보자.
- STATEMENT 포맷의 바이너리 로그: 트랜잭션 수행 시 실행된 모든 SQL 문장을 로그로 남긴다.
    - 쿼리 실행 환경에 따라 결과가 다를 수 있음
    - 그래서 현재는 ROW 포맷을 기본으로 제공한다고 한다.
    - ROW 포맷은 데이터의 결과 자체를 기록하므로 실행 환경에 따라 달라질 위험이 없다.
